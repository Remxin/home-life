// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: task.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addTask = `-- name: AddTask :one
INSERT INTO "tasks" (
    id,
    name,
    description,
    family_id,
    created_by,
    assigned_to,
    execution_date
) VALUES (
    gen_random_uuid(),
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
) RETURNING id, name, description, done, family_id, created_by, assigned_to, execution_date, created_at
`

type AddTaskParams struct {
	Name          string        `json:"name"`
	Description   string        `json:"description"`
	FamilyID      uuid.UUID     `json:"family_id"`
	CreatedBy     uuid.UUID     `json:"created_by"`
	AssignedTo    uuid.NullUUID `json:"assigned_to"`
	ExecutionDate time.Time     `json:"execution_date"`
}

func (q *Queries) AddTask(ctx context.Context, arg AddTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, addTask,
		arg.Name,
		arg.Description,
		arg.FamilyID,
		arg.CreatedBy,
		arg.AssignedTo,
		arg.ExecutionDate,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Done,
		&i.FamilyID,
		&i.CreatedBy,
		&i.AssignedTo,
		&i.ExecutionDate,
		&i.CreatedAt,
	)
	return i, err
}

const assignTask = `-- name: AssignTask :one
UPDATE "tasks"
SET assigned_to = $1
WHERE id = $2
RETURNING id, name, description, done, family_id, created_by, assigned_to, execution_date, created_at
`

type AssignTaskParams struct {
	AssignedTo uuid.NullUUID `json:"assigned_to"`
	ID         uuid.UUID     `json:"id"`
}

func (q *Queries) AssignTask(ctx context.Context, arg AssignTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, assignTask, arg.AssignedTo, arg.ID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Done,
		&i.FamilyID,
		&i.CreatedBy,
		&i.AssignedTo,
		&i.ExecutionDate,
		&i.CreatedAt,
	)
	return i, err
}

const deleteTask = `-- name: DeleteTask :one
DELETE FROM "tasks"
WHERE id = $1
RETURNING id, name, description, done, family_id, created_by, assigned_to, execution_date, created_at
`

func (q *Queries) DeleteTask(ctx context.Context, id uuid.UUID) (Task, error) {
	row := q.db.QueryRowContext(ctx, deleteTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Done,
		&i.FamilyID,
		&i.CreatedBy,
		&i.AssignedTo,
		&i.ExecutionDate,
		&i.CreatedAt,
	)
	return i, err
}

const getTasks = `-- name: GetTasks :many
SELECT id, name, description, done, family_id, created_by, assigned_to, execution_date, created_at FROM "tasks"
WHERE
    assigned_to = COALESCE($1, assigned_to) AND
    family_id = COALESCE($2, family_id) AND
    execution_date BETWEEN $3 AND $4
`

type GetTasksParams struct {
	AssignedTo uuid.NullUUID `json:"assigned_to"`
	FamilyID   uuid.NullUUID `json:"family_id"`
	DateFrom   time.Time     `json:"date_from"`
	DateTo     time.Time     `json:"date_to"`
}

func (q *Queries) GetTasks(ctx context.Context, arg GetTasksParams) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getTasks,
		arg.AssignedTo,
		arg.FamilyID,
		arg.DateFrom,
		arg.DateTo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Done,
			&i.FamilyID,
			&i.CreatedBy,
			&i.AssignedTo,
			&i.ExecutionDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markTaskAsDone = `-- name: MarkTaskAsDone :one
UPDATE "tasks"
SET done = true
WHERE id = $1
RETURNING id, name, description, done, family_id, created_by, assigned_to, execution_date, created_at
`

func (q *Queries) MarkTaskAsDone(ctx context.Context, id uuid.UUID) (Task, error) {
	row := q.db.QueryRowContext(ctx, markTaskAsDone, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Done,
		&i.FamilyID,
		&i.CreatedBy,
		&i.AssignedTo,
		&i.ExecutionDate,
		&i.CreatedAt,
	)
	return i, err
}
